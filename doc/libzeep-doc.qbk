[/
	Documentation for libzeep version 5.0

          Copyright Maarten L. Hekkelman, 2020
 Distributed under the Boost Software License, Version 1.0.
    (See accompanying file LICENSE_1_0.txt or copy at
          http://www.boost.org/LICENSE_1_0.txt)
]

[book libzeep
    [quickbook 1.7]
    [version 5.0]
    [id quickbook]
    [copyright 2020 Maarten L. Hekkelman]
    [authors [Hekkelman, Maarten L.]]
    [license 
		Distributed under the Boost Software License, Version 1.0.
        (See accompanying file LICENSE_1_0.txt or copy at
        [@http://www.boost.org/LICENSE_1_0.txt])
	]
    [source-mode c++]
]

[def __document__ [classref zeep::xml::document `zeep::xml::document`]]
[def __document__child__ [memberref zeep::xml::document::child `child`]]
[def __element__ [classref zeep::xml::element `element`]]
[def __node__ [classref zeep::xml::node `zeep::xml::node`]]
[def __element__ [classref zeep::xml::element `zeep::xml::element`]]
[def __text__ [classref zeep::xml::text `zeep::xml::text`]]
[def __cdata__ [classref zeep::xml::cdata `zeep::xml::cdata`]]
[def __comment__ [classref zeep::xml::comment `zeep::xml::comment`]]
[def __zeep_serializer__ [classref zeep::xml::serializer `zeep::xml::serializer`]]
[def __processing_instruction__ [classref zeep::xml::processing_instruction `zeep::xml::processing_instruction`]]
[def __preforked_server__ [classref zeep::http::preforked_server]]
[def __char_streambuf__ [classref zeep::char_streambuf]]
[def __value_serializer__ [classref zeep::value_serializer `zeep::value_serializer`]]

[def __json_element__ [classref zeep::json::element `zeep::json::element`]]

[include introduction.qbk]
[include lib-xml.qbk]
[include lib-json.qbk]
[include lib-http.qbk]
[include reference.qbk]

[/

[section:http HTTP Server]

Creating a HTTP server with libzeep is as simple as:

	#include <zeep/http/server.hpp>
	
	class my_server : public __http_server__
	{
		virtual void handle_request(const __http_request__& req, __http_reply__& rep)
		{
			...	// do something useful
		}
	};
	
	int main()
	{
		my_server server;
		server.bind("0.0.0.0", 80);
		server.run(1);
	}

Of course you will have to fill in the `handle_request` part...

[endsect]

[section:soap SOAP Server]

Setting up a SOAP server is very easy. Let's continue with our test file and serve it as a SOAP/REST server. We already created the Person struct. The most simple server we can create is one that lists all persons in the test file:

	#include <zeep/server.hpp>
	#include <fstream>
	
	using namespace std;
	
	... // define the Person struct as above
	
	class my_server : public __soap_server__
	{
	  public:
		my_server();
	
		// The method we want to export
		void ListPersons(vector<Person>& result);
	};
	
	void my_server::ListPersons(vector<Person>& result)
	{
		std::ifstream file("test.xml");
		__document__ doc(file);
		
		__deserializer__ ds(doc.child());
		ds & boost::serialization::make_nvp("person", result);
	}
	
	my_server::my_server() : __soap_server__("http://www.example.org/soaptest", "soaptest")
	{
		// assign a name to the Person struct (will appear in the WSDL e.g.)
		zeep::xml::serialize_struct<Person>::set_struct_name("person");
		
		// assign names to the parameters of the exported method, in this case there's only
		// one return value to name
		const char* kListPersonsParameterNames[] = { "response" };
		register_action("ListPersons", this, &my_server::ListPersons, kListPersonsParameterNames);
	}
	
	int main()
	{
		my_server server;
		server.bind("192.168.0.1", 8083);
		server.run(1);	// keep our server single threaded
	}

After building this server and running it, you can access the REST version of this routine at [@http://192.168.0.1:8083/rest/ListPersons] and there's a WSDL at [@http://192.168.0.1:8083/wsdl]

[endsect]

[endsect]

[section:soap Creating a SOAP and REST server]

[section:intro Introduction]

SOAP and REST are two ways to export functionality over the web. Both have their strongness and weakness. SOAP
enforces a strict type checking on input and output parameters. It works with a formal description file called WSDL
that specifies all the exposed functionality and how to invoke this. Many tools exist that can read WSDL files and
create client code that uses the exposed functions.

REST on the other hand, is much easier to use ad hoc. It passes the arguments to the invoked functions in the
URL and uses standard GET, POST and PUT methods of the HTTP protocol.

Since version 4.0 libzeep fully supports creating REST servers. This documentation first describes the way to create
a SOAP server followed by the steps to create a REST server.

[endsect]

[section:basics A real world SOAP example]

Creating a SOAP server using libzeep is very easy. The bulk of the work is done by libzeep, you only have
to specify what methods to expose and optionally what datatypes.

To demonstrate this, we will create a simple SOAP server that allows the client to search for documents in a
databank. Lets start with the initial code, the declaration of our server object.

	#include <zeep/server.hpp>
	
	using namespace std;
	
	class MyServer : public __soap_server__
	{
	  public:

	    struct MyHit
	    {
	      long   id;
	      float  score;
	      string title;
	      
	      template<class Archive>
	      void serialize(Archive& ar, const unsigned int version)
	      {
	        ar & BOOST_SERIALIZATION_NVP(id) & BOOST_SERIALIZATION_NVP(score) & BOOST_SERIALIZATION_NVP(title);
	      }
	    };
	    
	    enum MyAlgorithm
	    {
	      algVector, algDice, algJaccard
	    };

	    MyServer();
	
	    void CountDocuments(long& outCount);
	    void GetDocument(long inID, string& outDocument);
	    void FindDocument(const vector<string>& inTerms, MyAlgorithm inAlgorithm,
	    vector<MyHit>& outResponse);
	};

Nothing special so far. Apart from inheriting from __soap_server__, this code could have been
code you already had lying around. The addition of the `serialize` method to `MyHit` may also
have been new to the code. The implementation of the actual server methods are also straightforward:

	void MyServer::CountDocuments(long& outCount)
	{
	  long count = 1; 	// real code should return something more sensible of course
	  outCount = count;
	}
	
	void MyServer::GetDocument(long inID, string& outDocument)
	{
	  if (inID == 1)
	    outDocument = "The first document!";
	  else
	    throw zeep::exception("document %ld not found", inID);
	}
	
	void MyServer::FindDocument(const vector<string>& inTerms,
	  MyAlgorithm inAlgorithm, vector<MyHit>& outResponse)
	{
	  if (inTerms.size() == 1 and inAlgorithm == algVector)
	  {
	    MyHit hit = { 1, 1.0f, "The first hit" };
	    outResponse.push_back(hit);
	  }
	}

Not very useful code, but it gives you an idea how simple it is to create a server. You
don't have to do anything special, it's still code you could have written for some other
purpose. Note that the GetDocument method throws an exception. The result in a SOAP server
will be a SOAP Fault being returned containing the text 'document x not found'.

Unfortunately, this is not all that needs to be done, we still have to tell libzeep what
methods and what datatypes to expose. That's what we do in the constructor for `MyServer`.

	MyServer::MyServer()
	  : __soap_server__("http://www.example.org/MyServer", "searchMyServer")
	{
	  // first export the data types, start with MyHit
	  zeep::xml::serialize_struct<MyHit>::set_struct_name("hit");
	  
	  // and then the MyAlgorithm enum
	  zeep::xml::enum_map<MyAlgorithm>::instance("algorithm").add_enum()
	    ("vector", algVector)
	    ("dice", algDice)
	    ("jaccard", algJaccard);
	  
	  // Now export the methods, start with CountDocuments
	  const char* kCountDocumentsParamNames[] = { "response" };
	  register_action("CountDocuments", this, &MyServer::CountDocuments, kCountDocumentsParamNames);
	  
	  // then GetDocument
	  const char* kGetDocumentParamNames[] = { "id", "response" };
	  register_action("GetDocument", this, &MyServer::GetDocument, kGetDocumentParamNames);

	  const char* kFindDocumentParamNames[] = { "terms", "algorithm", "response" };
	  register_action("FindDocument", this, &MyServer::FindDocument, kFindDocumentParamNames);
	}

We start the constructor by calling the constructor of our base class, __soap_server__. We then
continue by exporting the data types. Our MyHit datatype is exported under the name 'hit' and
MyAlgorithm is exported as 'algorithm'. The various values of MyAlgorithm are exported under
a new name as well.

After exporting the datatypes, we export the methods. We do this by calling `register_action`
specifying the parameters for the exported method name, the callback to make and the names
for the parameters. And that's all. All that's left is to write a `main`.

	int main()
	{
	  MyServer server;
	  server.bind("0.0.0.0", 80);
	  server.run(1);
	}

And that will run our code in a single threaded server. If you run this code on your local machine
you can test the REST versions of the code by visiting the following URL's with a web browser:

[@http://localhost/rest/CountDocuments]	Will return a SOAP envelope containing *1* in a response element

[@http://localhost/rest/GetDocument/id/1]

[@http://localhost/rest/GetDocument/id/2]	Will return a SOAP Fault

[@http://localhost/rest/FindDocument/terms/bla/algorithm/vector]


[endsect]

[section:basics And a real world REST example]

Just like the SOAP server, creating a REST server is pretty easy. This time we will use the
new __rest_controller__ class. This is a concept borrowed from Spring, the controller handles
HTTP requests done in a subdomain. The path to this domain is specified in the constructor.

Here's the declaration of our MyController class:[c++]

	class MyController : public __rest_controller__
	{
	  public:
	..  MyController();
	
	    // this is similar 
	    struct MyHit
	    {
	      long   id;
	      float  score;
	      string title;
	      
	      template<class Archive>
	      void serialize(Archive& ar, const unsigned int version)
	      {
	        ar & zeep::make_nvp("id", id) & zeep::make_nvp("score", score) & zeep::make_nvp("title", title);
	      }
	    };
	    
	    enum class MyAlgorithm
	    {
	      vector, dice, jaccard
	    };
	    
	    long CountDocuments();
	    string GetDocument(long inID);
	    vector<MyHit> FindDocument(const vector<string>& inTerms, MyAlgorithm inAlgorithm);
	};	

This looks even better than our SOAP server. We simply return the values, no need to have the result as last
reference parameter.The REST controller converts basic types into strings and complex types into JSON. A full
JSON implementation is available as __el_object__ class. The implementation of this class follows the implementation
of N.Lohmann's json library very closely.

To help in serialization, helper functions need to be created. For MyAlgorithm we have e.g.:[c++]

	void to_element(__el_object__& e, MyAlgorithm algorithm)
	{
	  switch (algorithm)
	  {
	    case MyAlgorithm::vector:    e = "vector"; break;
	    case MyAlgorithm::dice:      e = "dice"; break;
	    case MyAlgorithm::jaccard:   e = "jaccard"; break;
	  }
	}
	
	void from_element(const __el_object__& e, MyAlgorithm& algorithm)
	{
	  if (e == "vector")       algorithm = MyAlgorithm::vector;
	  else if (e == "dice")    algorithm = MyAlgorithm::dice;
	  else if (e == "jaccard") algorithm = MyAlgorithm::jaccard;
	}

Now all we need is the constructor for MyController where we bind the methods to the REST logic. Important to
know here is that REST uses PUT, GET, POST and DELETE as HTTP methods. We can bind to these methods specifically.

	MyController::MyController()
	  : __rest_controller__("ajax")
	{
	  add_get_request("count", &MyController::CountDocuments);
	  add_get_request("document/{id}", &MyController::GetDocument, "id");
	  add_get_request("find", &MyController::FindDocument, "terms", "algorithm");
	  add_post_request("find", &MyController::FindDocument, "terms", "algorithm");
	}

And that's all. Note that we added FindDocument twice, once as a GET request and once as a POST. This allows
the client of this server to use either method.

The parameters of the exposed methods are named in the add_xxx_request call. The number of name arguments
must of course match the number of arguments in the exposed method. By default parameters are taken from
request parameters or the POST payload. But if you specify the name in accolades in the path they will
be taken from there.

[endsect]

[endsect]

[section:html Creating a Web Application]

[section:intro Introduction]

This section will guide you through all the code you have to write to create an interactive web
application using libzeep. The way this works in libzeep looks a lot like popular frameworks
found for Java. If you're familiar with JSP and e.g. Struts, you'll notice the similarities.

[endsect]

[section:basics The building blocks]

It is very inconvenient to write HTML code in C++ directly using string concatenations and streams.
Therefore, a separation has been made. All HTML is put into XHTML template files. These template
files can use special tags to generate HTML tags based on data provided by the server application.
A script language that looks a lot like JSP 'Expression Language' (or =el= in short) is used to
program conditional constructs. Communication between this =el= script and the server application
is done via =el::object= data objects.

[endsect]

[section:hello Hello world!]

Let's start with a simple hello world example. We first create a template file, save
this file as =hello.xhtml=.[teletype]

	<?xml version="1.0" encoding="UTF-8"?>
	<!DOCTYPE xhtml PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/1999/xhtml">
	<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
	  <title>Hello</title>
	</head>
	<body>
	  <p>Hello, world!</p>
	</body>
	</html>

This is a very simple, strict XHTML 1.1 file. We will serve it with our server:[c++]

	#include <zeep/http/html.hpp>
	#include <functional>
	
	using namespace std;
	
	class MyWebApp : public __html__
	{
	  public:
	    MyWebApp();
	    
	    void handle_welcome(const __http_request__& request,
	           const __el_scope__& scope, __http_reply__& reply);
	};
	
	MyWebApp::MyWebApp()
	{
    using namespace std::placeholders;
	  mount("",      bind(&MyWebApp::handle_welcome, this, _1, _2, _3));
	}
	
	void MyWebApp::handle_welcome(const __http_request__& request,
	           const __el_scope__& scope, __http_reply__& reply)
	{
	  create_reply_from_template("hello.xhtml", scope, reply);
	}
	
	int main()
	{
	  MyWebApp server;
	  server.bind("0.0.0.0", 80);
	  server.run(1);
	}
	
By calling `mount` with the empty string, we tell libzeep to redirect
all access to the base URL to handle_welcome. This means that visiting
the URL [@http://localhost/] should now return a page containing the string
'Hello, world!'.

[endsect]

[section:forms Using forms]

Now lets create a form to pass some data from the browser to the server
and back. Save the following file as =form.xhtml=.[teletype]

	<?xml version="1.0" encoding="UTF-8"?>
	<!DOCTYPE xhtml PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/1999/xhtml">
	<html xmlns="http://www.w3.org/1999/xhtml" xmlns:zeep="http://www.cmbi.ru.nl/libzeep/ml">
	<head>
	  <title>Form example</title>
	</head>
	<body>
	  <zeep:if test="${name}">
	    <p>Hello ${name}!</p>
	  </zeep:if>
	  <p>Please enter your name and press the Submit button</p>
	  <form id="myForm" action="salute" method="get">
	    <label>Name: <input id="name" type="text" name="name" value="${name}"/></label>
	    <input type="submit" value="Submit" />
	  </form>
	</body>
	</html>

We add the zeep prefix to our html tag, it has the value ="http://www.cmbi.ru.nl/libzeep/ml"=
which is the same as the default value for the `ns` parameter in the __html__ constructor.
Note that the input tag has an attribute with value '${data}'. This is a piece of
expression language script. This will be explained below:[c++]

	#include <zeep/http/html.hpp>
	#include <zeep/http/html/el.hpp>
	
	using namespace std;
	
	class MyWebApp : public __html__
	{
	  public:
	    MyWebApp();
	    
	    void handle_welcome(const __http_request__& request,
	           const __el_scope__& scope, __http_reply__& reply);
	    void handle_salute(const __http_request__& request,
	           const __el_scope__& scope, __http_reply__& reply);
	};
	
	MyWebApp::MyWebApp()
	{
	  mount("",       bind(&MyWebApp::handle_welcome, this, _1, _2, _3));
	  mount("salute", bind(&MyWebApp::handle_salute, this, _1, _2, _3));
	}
	
	void MyWebApp::handle_welcome(const __http_request__& request,
	           const __el_scope__& scope, __http_reply__& reply)
	{
	  create_reply_from_template("form.xhtml", scope, reply);
	}
	
	void MyWebApp::handle_salute(const __http_request__& request,
	           const __el_scope__& scope, __http_reply__& reply)
	{
	  zeep::http::parameter_map params;
	  get_parameters(scope, params);
	
	  string name = params.get("name", "").as<string>();
	
	  __el_scope__ sub(scope);
	  sub.put("name", name);
	
	  create_reply_from_template("form.xhtml", sub, reply);
	}
	
	int main()
	{
	  MyWebApp server;
	  server.bind("0.0.0.0", 80);
	  server.run(1);
	}
	
This time, we add a new handler for the 'salute' page. The form has an action that
points to this salute page. As can be seen in the `handle_salute` method, we first
collect the parameters passed in. Parameters are accessed by name. We then create a
sub scope of the scope passed in. In this sub scope we put the value of the parameter
so that the XHTML processor can access it. And then we return a reply based on the
contents of the =form.xhtml= template and the contents of the sub scope we created.

[endsect]
]